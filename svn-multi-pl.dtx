% \iffalse
%<*driver>
\def\filedate$#1: #2 #3 #4-#5-#6 #7 ${%
 \year#4\month#5\day#6\relax
 \def\filedate{#4/#5/#6}%
}
\filedate$Id$
\def\fileversion{v0.1}
\ProvidesFile{svn-multi-pl.dtx}
 [\filedate\space\fileversion\space SVN Keywords extractor for svn-multi]

\documentclass{ltxdoc}
\usepackage{ifpdf}
\ifpdf
    % use hypdoc if you have it, hyperref else
    %\usepackage[hyperfootnotes=false]{hyperref}
    \usepackage{hypdoc}
\else\let\url=\texttt\fi
\usepackage{xspace}
\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\eg}{e.g.\@\xspace}

\newenvironment{sub}{\begin{macro}}{\end{macro}}

%\EnableCrossrefs
\DisableCrossrefs
\CodelineIndex
%\PageIndex
%\RecordChanges
\begin{document}
  %\OnlyDescription
  \DocInput{\jobname.dtx}%
  %\PrintChanges
  %\clearpage
  %\PrintIndex
\end{document}
%</driver>
%<*script>
%\fi
%
% \CheckSum{0}
%
% {\makeatother
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
% }
% \iffalse " \fi
%
% \title{The \textsf{svn-multi.pl} script\thanks{This document
%   corresponds to \textsf{svn-multi.pl}~\fileversion, dated \filedate.}}
% \author{Martin Scharrer \\ \url{martin@scharrer-online.de} \\
% \url{http://www.scharrer-online.de/latex/svn-multi}}
%
% \ifpdf
% \hypersetup{
%	pdfauthor={Martin Scharrer <martin@scharrer-online.de>},
%	pdftitle={The svn-multi.pl script},
%	pdfsubject={Documentation of Perl script svn-multi.pl which allows the
%	typesetting of external Subversion keywords in multi-file LaTeX documents},
%	pdfkeywords={svn-multi, svnkw, LaTeX, Subversion, keywords, Version
%	Control, Id, script}
% }
% \fi
% \maketitle
% \section{Usage}
% See the section in the |svn-multi| package manual.
%
% \StopEventually{}
% \section{Implementation}
% The implementation description is still work in progress.
%
% \iffalse
#!/usr/bin/perl
################################################################################
# Copyright (c) 2009 Martin Scharrer <martin@scharrer-online.de>
# This is open source software under the GPL v3 or later.
#
# This script belongs to the LaTeX package 'svn-multi'.
# Version: 2009/03/02
#
# $Id$
################################################################################
% \fi
%    \begin{macrocode}
use strict;
use warnings;
use File::Basename;

my $VERSION = "0.1";
my ($REV,$DATE) = 
    (split ' ','$Id$')[2,3];

my $dollar  = '$';

my %EXCLUDE = map { $_ => 1 } qw(sty tex aux log out toc fff ttt svn svx);
my @PATH;

sub create_svxfile ($@);

if (!@ARGV or $ARGV[0] eq '--help' or $ARGV[0] eq '-h') {
    usage();
}

print STDOUT "This is svn-multi.pl, Version $VERSION-$REV, $DATE\n";
%    \end{macrocode}

% \begin{sub}{usage}
% Prints usage information.
%    \begin{macrocode}
sub usage {
    print STDOUT <<'EOT';
Usage:
 svn-multi.pl jobname[.tex] [--fls] [--group|-g <group name>] [input_files] ...
 ... [--group|-g <group name>] [input_files] ...

Description:
 This LaTeX helper script collects Subversion keywords from non-(La)TeX files
 and provides it to the 'svn-multi' package using '.svx' files.  It will first
 scan the file '<jobname>.svn' for files declared by the '\svnextern' macro but
 also allows to provide additional files including the corresponding
 groups. The keywords for the additional files will be written in the file
 '<jobname>.svx'.

Options:
 jobname[.tex] : The LaTeX `jobname`, i.e. the basename of your main LaTeX file.
 --group <GN>  : Use given group name <GN> for all following files,
 or -g <GN>      including the one read by a '--fls' option, until the next
                 group is specified.
 --fls  : Read list of (additional) files from the file '<jobname>.fls'. This
          file is produced by LaTeX when run with the '--recorder' option and
          contains a list of all input and output files used by the LaTeX main
          file. Only input files with a relative path will be used.
          A previously selected group will be honoured.

Examples:
The main LaTeX file here is 'mymainlatexfile.tex'.

 svn-multi.pl mymainlatexfile
    Creates Subversion keywords for all files declared by '\svnextern' inside
    the LaTeX code.

 svn-multi.pl mymainlatexfile --group=FLS --fls
    Creates Subversion keywords for all files declared by '\svnextern' inside
    the LaTeX code. In addition it does the same for all relative input files
    mentioned in the .fls file which are placed in the 'FLS' group.

 svn-multi.pl mymainlatexfile a b c --group=B e d f
    In addition to the '\svnextern' declared files the keywords for the files
    'a', 'b' and 'c' will be added without a specific group, i.e. the last
    group specified in the LaTeX file before the '\svnextern' macro will
    be used. The keywords for 'e', 'd', 'f' will be part of group 'B'.

 svn-multi.pl mymainlatexfile --group=A a --group=B b --group='' c
    File 'a' is in group 'A', 'b' is in 'B' and 'c' is not in any group.

Further Information:
See the svn-multi package manual for more information about this script.
EOT
    exit(0);
}
%    \end{macrocode}
% \end{sub}

%    \begin{macrocode}
my ($jobname, $dir, $suffix) = fileparse(shift @ARGV, qr/\.(tex|ltx|dtx|svn)$/);
print "suffix: $suffix\n";
if ($dir && $dir ne './') {
  printf STDOUT "Main directory is '$dir'.\n";
  chdir($dir);
}

if ($jobname =~ /^-/) {
    usage();
}
my $outfile = "$jobname.svx";

my %external;

if (-e "$jobname.svn" and open( my $svnfh, '<', "$jobname.svn")) {
    print STDOUT "Reading '$jobname.svn'.\n";
    while (<$svnfh>) {
        chomp;
        if    (/^\s*\\\@svnexternalpath\s*{\s*(?:{(.*)}|)\s*}\s*$/) {
            push @PATH, ( split /}\s*{/, $1 );
        }
        elsif (/^\s*\\\@svnexternal\s*{([^}]+)}\s*{\s*(?:{(.*)}|)\s*}\s*$/) {
            my ($name,$list) = ($1,$2||"");
            $name =~ s/^\.\///;
            push @{$external{$name} ||= []}, ( split /}\s*{/, $list );
        }
    }
    foreach my $list (values %external) {
        my %temp = map { $_ => 1 } @$list;
        $list = [ keys %temp ];
    }
    close ($svnfh);
}
else {
    warn "No .svn file found for '$jobname'!\n";
}

# Add TEXINPUTS to path
push @PATH, map { $_ =~ s/(?<!\/)$/\//; $_ } grep { $_ } 
                split(':', $ENV{'TEXINPUTS'}||"");

my @mainfilepairs;
if (exists $external{"$jobname.tex"}) {
    @mainfilepairs = (['', @{$external{"$jobname.tex"}||[]}]);
    delete $external{"$jobname.tex"};
}
push @mainfilepairs, parse_args(@ARGV);
create_svxfile("$jobname.svx", @mainfilepairs )
    if @mainfilepairs;

while ( my ($texfile, $extlist) = each %external ) {
    my $svxfile = $texfile;
    $svxfile =~ s/\.(tex|ltx)$/.svx/;
    create_svxfile($svxfile, ['', @$extlist]);
}
%    \end{macrocode}

% \begin{sub}{parse args}
% Parses the arguments and builds a list of (group,files) pairs
%    \begin{macrocode}
sub parse_args {
    my @args = @_;
    my $group = '';
    my @files;
    my $readfg;
    my @pairs;

    foreach my $arg (@args) {
        if ($readfg) {
            $readfg    = 0;
            $group = $arg;
            $group =~ s/^["']|["']$//; # '
        }
        elsif ($arg =~ /^--group|^-?-fg/) {
            push @pairs, [ $group, @files ];
            @files = ();
            if ($arg =~ /^--group=(.*)/) {
                $group = $1;
                $group =~ s/^["']|["']$//; # '
            }
            else {
                $readfg = 1;
            }
        }
        elsif ($arg =~ /^--fls/) {
            push @files, read_fls("$jobname.fls");
        }
        else {
            push @files, $arg;
        }
    }
    push @pairs, [ $group, @files ] if @files;
    return @pairs;
}

%    \end{macrocode}
% \end{sub}

% \begin{sub}{read fls}
%    \begin{macrocode}
sub path_search {
    my $file = shift;
    $file =~ s/##/#/g;
    return $file if not $file or -e $file or not @PATH;

    foreach my $dir (@PATH) {
        if (-e "$dir$file") {
            return "$dir$file";
        }
    }

    return $file;
}
%    \end{macrocode}
% \end{sub}

% \begin{sub}{ceate svxfile}
%    \begin{macrocode}
sub create_svxfile ($@) {
    my ($svxfile, @fgpair) = @_;
    my $lastgroup = '';
    my $fgused = 0;
    open(my $svxfh, '>', $svxfile) or do {
        warn "ERROR: Could not create SVX file '$svxfile'!\n";
        return;
    };
    return if not @fgpair;
    print STDOUT "Generating .svx file '$svxfile'.\n";
    select $svxfh;
    print "% Generated by svn-multi.pl v$VERSION\n\n";

    while ( my ($group, @files) = @{shift @fgpair||[]}) {
    if ($group ne $lastgroup) {
        print "\\svngroup{$group}\n";
    }
    if ($group) {
        $fgused = 1;
    }

    foreach my $file (@files) {
        $file = path_search($file);
        open(my $infoh, '-|', "svn info '$file' 2>/dev/null") or next;
        my %info = map { chomp; split /\s*:\s*/, $_, 2 } <$infoh>;
        close($infoh);
        if (not keys %info) {
            print "% Could not receive keywords for '$file'!\n\n";
            next;
        }
        print "% Keywords for '$file'\n";
        print svnidlong(\%info);
        print "\\svnexternalfile{$file}\n";
        print "\n"
    }

    $lastgroup = $group;
    }
    print "\\svngroup{}\n" if $fgused and $lastgroup ne '';
    print "\n";
    close ($svxfh);
}
%    \end{macrocode}
% \end{sub}

% \begin{sub}{svnid}
% Generates a svnid macro line.
%    \begin{macrocode}
sub svnid {
    use Date::Parse;
    use Date::Format;
    my $href = shift;
    return "" if (not defined $href->{Name});
    my $date = time2str("%Y-%m-%d %XZ", str2time($href->{'Last Changed Date'}), 'Z');
    return <<"EOT";
\\svnid{${dollar}Id: $href->{Name} $href->{'Last Changed Rev'} $date $href->{'Last Changed Author'} \$}
EOT
}
%    \end{macrocode}
% \end{sub}

% \begin{sub}{svnidlong}
% Generates svnidlong macro lines.
%    \begin{macrocode}
sub svnidlong {
    my $href = shift;
    return <<"EOT";
\\svnidlong
{${dollar}HeadURL: $href->{URL} \$}
{${dollar}LastChangedDate: $href->{'Last Changed Date'} \$}
{${dollar}LastChangedRevision: $href->{'Last Changed Rev'} \$}
{${dollar}LastChangedBy: $href->{'Last Changed Author'} \$}
EOT
}
%    \end{macrocode}
% \end{sub}

% \begin{sub}{read fls}
%    \begin{macrocode}
sub read_fls {
    my $fls = shift;
    my %stack;
    open (my $fh, '<', $fls) or return;
    while (<$fh>) {
        chomp;
        if (/^INPUT ([^\/].*)$/) {
            my $file = $1;
            my $ext = substr($file, rindex($file,'.')+1);
            $stack{$1} = 1 if not exists $EXCLUDE{$ext};
        }
    }
    close($fh);
    return keys %stack;
}
%    \end{macrocode}
% \end{sub}
% \Finale
% \iffalse
%</script>
% \fi
